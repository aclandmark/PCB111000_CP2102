


*********************


Full Project commentary
Page 1:
Our first project a simple C program is based on JP’s Blinky, p30.   A selection is offered here.  Why not choose one and type it in. Once it compiles upload the hex file select ‘r’ for run and watch the leds go (hopefully!). *    

***Look at JP chapter 3 for an intro to Blinky.    Now look again at your own code and notice several lines:

#include “First_project_header.h”  and setup_328_HW;  (k/a a macro)
Open the header file, it contains a definition for setup_328_HW (Hard Ware)
Unsigned int PORT_1	PORT_1 is the name of a memory location that holds numbers
One_wire_Tx_2_integers(PORT_1, PORT_1)	This is a resource which sends data over the one wire link to the ATtiny device which uses it to drive the display
sei(); 	This enables interrupts which are required by the one wire link (and will be discussed later)
SW_reset;	This is also a macro. It uses a device k/a a watch dog timer wtd to reset the program so that it repeats endlessly.*

***Try several examples, they provide good practice at entering programs
Many of then contain logic statements the meaning of which can be found in JP chapter 4

Example 8 introduces the resources
	PRN_16bit_GEN(0) which generates random numbers
	Timer_T2_10mS_delay_x_m() which uses a HW timer to generate delays

Example 9 introduces a project subroutine “backup_the_display()”
	This provides a service for the main routine
	Its main purpose here is to make the code easier to read 

Having looked at the examples why not mix and match to compose your own code.*

***Page 2
Many devices have a receiver transmitter module (UART) for communicating with a PC.
See JP page 98 for a few details.
Arduino provides a comprehensive set of functions for using the UART.  Here basic DIY functions are used to encourage us to consult the data sheet which is not nearly as intimidating as it looks at first sight.
Example 1 simply echoes keypresses to the screen
Example 2  prints many of the common characters to the screen 
Clicking on the hex button in the receive section of the Bray window shows that each character is represented by a number. See JP p283.*
***Example 3 prints a file. 
Resource “isCharavailable()” repetitively waits to receive the user to initiate the file upload.
It then notes that the upload has ended and terminates the program.
Example 4 introduces character strings and shows they can be sent to the PC. 
It also shows how they are stored in memory.
We compose the strings and choose a name for each one.
 The compiler adds a 0 to the end of each string and replaces its name with the address in memory of the first character in the string.   
Example 5 simple prints out the characters together with their numeric equivalents
Example 6 Converts a number to a string of characters and sends them to the PC and
Example 7 Does the reverse.
These are two very important operations  So take time to understand what is going on.
See JP pages 81 to 84 for some help.*

***Finally take a look at the subroutine Char_to_PC()
UCSR0A one of the HW registers that control the UART.
Open the data sheet. In the contents open section scroll down to section 24.12.2
UDRE0 is the name of one of the bits in this register. If it is 0 the UART is busy so we wait
If its 1 we can copy our character to UDR0 the UART data register and it will be transmitted. 
Scroll up a bit for more info on the register UDR0.*


***Page 3
3A looks at timer and keypress interrupts. 
Se JP p109 for a general intro.
When driving the display the micro spends most of its time doing nothing waiting for the end of our 100mS delay before updating the display. 
In this example the main task is printing out the results of some calculations. 
A HW timer is used to generate a 100mS tick.
Every 100mS it interrupts the printing process jumps to the ISR (interrupt service routine) update the display.
In addition a key press interrupt is shown to manipulate the display.*

***Look at the timer clock_tick() subroutine.
The timer is configured as a counter.
It counts from 0 to 12500 
TCCR1B sets a timer clock to 125KHz
So it takes 100ms to complete counting raise an interrupt and start again.*

***Both timer and UART have control registers that set their modes of operation. These registers have addresses and are all connected to a control bus.  A statements like TCCR1B = 0x03 uses the control bus to set register TCCR1B to 3. A bus refers to a set of connectors that transfer data from one part of the micro to another, in this case from the program running in memory to the timer.

Open up the data sheet section 15.11 to see the registers. We leave most of them alone but
set TCCR1B, TIMSK1 OCR1 and TCNT1.*

***3B looks at interrupts generated by pressing one of the user switches.
PCI stands for pin change interrupt.
Look at the header file for definitions of the macros.
See the data sheet sections 12.2.4 and 1 for detains of the PCI registers.

Note: Many things may look confusing.   If that each example successfully introduce one new thing that will be fine.*

***3C	Nothing new here, just included for a bit if extra practice

3D	Includes PCI and timer as well as the one wire comms interrupt.  Multiple interrupts can easily cause trouble.  To avoid this the PCI also resets the micro.  Before doing so it writes to the EEPROM.  After the reset it reads the EEPROM so that it knows which switch was pressed.  EEPROM is a special area of memory that survives power down and reset, which both usually result in all registers being reset to zero.
*



***Full Project commentary
Page 1:
Our first project a simple C program is based on JP’s Blinky, p30.   A selection is offered here.  Why not choose one and type it in. Once it compiles upload the hex file select ‘r’ for run and watch the leds go (hopefully!). *    

***Look at JP chapter 3 for an intro to Blinky.    Now look again at your own code and notice several lines:

#include “First_project_header.h”  and setup_328_HW;  (k/a a macro)
Open the header file, it contains a definition for setup_328_HW (Hard Ware)
Unsigned int PORT_1	PORT_1 is the name of a memory location that holds numbers
One_wire_Tx_2_integers(PORT_1, PORT_1)	This is a resource which sends data over the one wire link to the ATtiny device which uses it to drive the display
sei(); 	This enables interrupts which are required by the one wire link (and will be discussed later)
SW_reset;	This is also a macro. It uses a device k/a a watch dog timer wtd to reset the program so that it repeats endlessly.*

***Try several examples, they provide good practice at entering programs
Many of then contain logic statements the meaning of which can be found in JP chapter 4

Example 8 introduces the resources
	PRN_16bit_GEN(0) which generates random numbers
	Timer_T2_10mS_delay_x_m() which uses a HW timer to generate delays

Example 9 introduces a project subroutine “backup_the_display()”
	This provides a service for the main routine
	Its main purpose here is to make the code easier to read 

Having looked at the examples why not mix and match to compose your own code.*

***Page 2
Many devices have a receiver transmitter module (UART) for communicating with a PC.
See JP page 98 for a few details.
Arduino provides a comprehensive set of functions for using the UART.  Here basic DIY functions are used to encourage us to consult the data sheet which is not nearly as intimidating as it looks at first sight.
Example 1 simply echoes keypresses to the screen
Example 2  prints many of the common characters to the screen 
Clicking on the hex button in the receive section of the Bray window shows that each character is represented by a number. See JP p283.*
***Example 3 prints a file. 
Resource “isCharavailable()” repetitively waits to receive the user to initiate the file upload.
It then notes that the upload has ended and terminates the program.
Example 4 introduces character strings and shows they can be sent to the PC. 
It also shows how they are stored in memory.
We compose the strings and choose a name for each one.
 The compiler adds a 0 to the end of each string and replaces its name with the address in memory of the first character in the string.   
Example 5 simple prints out the characters together with their numeric equivalents
Example 6 Converts a number to a string of characters and sends them to the PC and
Example 7 Does the reverse.
These are two very important operations  So take time to understand what is going on.
See JP pages 81 to 84 for some help.*

***Finally take a look at the subroutine Char_to_PC()
UCSR0A one of the HW registers that control the UART.
Open the data sheet. In the contents open section scroll down to section 24.12.2
UDRE0 is the name of one of the bits in this register. If it is 0 the UART is busy so we wait
If its 1 we can copy our character to UDR0 the UART data register and it will be transmitted. 
Scroll up a bit for more info on the register UDR0.*


***Page 3
3A looks at timer and keypress interrupts. 
Se JP p109 for a general intro.
When driving the display the micro spends most of its time doing nothing waiting for the end of our 100mS delay before updating the display. 
In this example the main task is printing out the results of some calculations. 
A HW timer is used to generate a 100mS tick.
Every 100mS it interrupts the printing process jumps to the ISR (interrupt service routine) update the display.
In addition a key press interrupt is shown to manipulate the display.*

***Look at the timer clock_tick() subroutine.
The timer is configured as a counter.
It counts from 0 to 12500 
TCCR1B sets a timer clock to 125KHz
So it takes 100ms to complete counting raise an interrupt and start again.*

***Both timer and UART have control registers that set their modes of operation. These registers have addresses and are all connected to a control bus.  A statements like TCCR1B = 0x03 uses the control bus to set register TCCR1B to 3. A bus refers to a set of connectors that transfer data from one part of the micro to another, in this case from the program running in memory to the timer.

Open up the data sheet section 15.11 to see the registers. We leave most of them alone but
set TCCR1B, TIMSK1 OCR1 and TCNT1.*

***3B looks at interrupts generated by pressing one of the user switches.
PCI stands for pin change interrupt.
Look at the header file for definitions of the macros.
See the data sheet sections 12.2.4 and 1 for detains of the PCI registers.

Note: Many things may look confusing.   If that each example successfully introduce one new thing that will be fine.*

***3C	Nothing new here, just included for a bit if extra practice

3D	Includes PCI and timer as well as the one wire comms interrupt.  Multiple interrupts can easily cause trouble.  To avoid this the PCI also resets the micro.  Before doing so it writes to the EEPROM.  After the reset it reads the EEPROM so that it knows which switch was pressed.  EEPROM is a special area of memory that survives power down and reset, which both usually result in all registers being reset to zero.
*



******Full Project commentary
Page 1:
Our first project a simple C program is based on JP’s Blinky, p30.   A selection is offered here.  Why not choose one and type it in. Once it compiles upload the hex file select ‘r’ for run and watch the leds go (hopefully!). *    

***Look at JP chapter 3 for an intro to Blinky.    Now look again at your own code and notice several lines:

#include “First_project_header.h”  and setup_328_HW;  (k/a a macro)
Open the header file, it contains a definition for setup_328_HW (Hard Ware)
Unsigned int PORT_1	PORT_1 is the name of a memory location that holds numbers
One_wire_Tx_2_integers(PORT_1, PORT_1)	This is a resource which sends data over the one wire link to the ATtiny device which uses it to drive the display
sei(); 	This enables interrupts which are required by the one wire link (and will be discussed later)
SW_reset;	This is also a macro. It uses a device k/a a watch dog timer wtd to reset the program so that it repeats endlessly.*

***Try several examples, they provide good practice at entering programs
Many of then contain logic statements the meaning of which can be found in JP chapter 4

Example 8 introduces the resources
	PRN_16bit_GEN(0) which generates random numbers
	Timer_T2_10mS_delay_x_m() which uses a HW timer to generate delays

Example 9 introduces a project subroutine “backup_the_display()”
	This provides a service for the main routine
	Its main purpose here is to make the code easier to read 

Having looked at the examples why not mix and match to compose your own code.*

***Page 2
Many devices have a receiver transmitter module (UART) for communicating with a PC.
See JP page 98 for a few details.
Arduino provides a comprehensive set of functions for using the UART.  Here basic DIY functions are used to encourage us to consult the data sheet which is not nearly as intimidating as it looks at first sight.
Example 1 simply echoes keypresses to the screen
Example 2  prints many of the common characters to the screen 
Clicking on the hex button in the receive section of the Bray window shows that each character is represented by a number. See JP p283.*
***Example 3 prints a file. 
Resource “isCharavailable()” repetitively waits to receive the user to initiate the file upload.
It then notes that the upload has ended and terminates the program.
Example 4 introduces character strings and shows they can be sent to the PC. 
It also shows how they are stored in memory.
We compose the strings and choose a name for each one.
 The compiler adds a 0 to the end of each string and replaces its name with the address in memory of the first character in the string.   
Example 5 simple prints out the characters together with their numeric equivalents
Example 6 Converts a number to a string of characters and sends them to the PC and
Example 7 Does the reverse.
These are two very important operations  So take time to understand what is going on.
See JP pages 81 to 84 for some help.*

***Finally take a look at the subroutine Char_to_PC()
UCSR0A one of the HW registers that control the UART.
Open the data sheet. In the contents open section scroll down to section 24.12.2
UDRE0 is the name of one of the bits in this register. If it is 0 the UART is busy so we wait
If its 1 we can copy our character to UDR0 the UART data register and it will be transmitted. 
Scroll up a bit for more info on the register UDR0.*


***Page 3
3A looks at timer and keypress interrupts. 
Se JP p109 for a general intro.
When driving the display the micro spends most of its time doing nothing waiting for the end of our 100mS delay before updating the display. 
In this example the main task is printing out the results of some calculations. 
A HW timer is used to generate a 100mS tick.
Every 100mS it interrupts the printing process jumps to the ISR (interrupt service routine) update the display.
In addition a key press interrupt is shown to manipulate the display.*

***Look at the timer clock_tick() subroutine.
The timer is configured as a counter.
It counts from 0 to 12500 
TCCR1B sets a timer clock to 125KHz
So it takes 100ms to complete counting raise an interrupt and start again.*

***Both timer and UART have control registers that set their modes of operation. These registers have addresses and are all connected to a control bus.  A statements like TCCR1B = 0x03 uses the control bus to set register TCCR1B to 3. A bus refers to a set of connectors that transfer data from one part of the micro to another, in this case from the program running in memory to the timer.

Open up the data sheet section 15.11 to see the registers. We leave most of them alone but
set TCCR1B, TIMSK1 OCR1 and TCNT1.*

***3B looks at interrupts generated by pressing one of the user switches.
PCI stands for pin change interrupt.
Look at the header file for definitions of the macros.
See the data sheet sections 12.2.4 and 1 for detains of the PCI registers.

Note: Many things may look confusing.   If that each example successfully introduce one new thing that will be fine.*

***3C	Nothing new here, just included for a bit if extra practice

3D	Includes PCI and timer as well as the one wire comms interrupt.  Multiple interrupts can easily cause trouble.  To avoid this the PCI also resets the micro.  Before doing so it writes to the EEPROM.  After the reset it reads the EEPROM so that it knows which switch was pressed.  EEPROM is a special area of memory that survives power down and reset, which both usually result in all registers being reset to zero.
*



***Full Project commentary
Page 1:
Our first project a simple C program is based on JP’s Blinky, p30.   A selection is offered here.  Why not choose one and type it in. Once it compiles upload the hex file select ‘r’ for run and watch the leds go (hopefully!). *    

***Look at JP chapter 3 for an intro to Blinky.    Now look again at your own code and notice several lines:

#include “First_project_header.h”  and setup_328_HW;  (k/a a macro)
Open the header file, it contains a definition for setup_328_HW (Hard Ware)
Unsigned int PORT_1	PORT_1 is the name of a memory location that holds numbers
One_wire_Tx_2_integers(PORT_1, PORT_1)	This is a resource which sends data over the one wire link to the ATtiny device which uses it to drive the display
sei(); 	This enables interrupts which are required by the one wire link (and will be discussed later)
SW_reset;	This is also a macro. It uses a device k/a a watch dog timer wtd to reset the program so that it repeats endlessly.*

***Try several examples, they provide good practice at entering programs
Many of then contain logic statements the meaning of which can be found in JP chapter 4

Example 8 introduces the resources
	PRN_16bit_GEN(0) which generates random numbers
	Timer_T2_10mS_delay_x_m() which uses a HW timer to generate delays

Example 9 introduces a project subroutine “backup_the_display()”
	This provides a service for the main routine
	Its main purpose here is to make the code easier to read 

Having looked at the examples why not mix and match to compose your own code.*

***Page 2
Many devices have a receiver transmitter module (UART) for communicating with a PC.
See JP page 98 for a few details.
Arduino provides a comprehensive set of functions for using the UART.  Here basic DIY functions are used to encourage us to consult the data sheet which is not nearly as intimidating as it looks at first sight.
Example 1 simply echoes keypresses to the screen
Example 2  prints many of the common characters to the screen 
Clicking on the hex button in the receive section of the Bray window shows that each character is represented by a number. See JP p283.*
***Example 3 prints a file. 
Resource “isCharavailable()” repetitively waits to receive the user to initiate the file upload.
It then notes that the upload has ended and terminates the program.
Example 4 introduces character strings and shows they can be sent to the PC. 
It also shows how they are stored in memory.
We compose the strings and choose a name for each one.
 The compiler adds a 0 to the end of each string and replaces its name with the address in memory of the first character in the string.   
Example 5 simple prints out the characters together with their numeric equivalents
Example 6 Converts a number to a string of characters and sends them to the PC and
Example 7 Does the reverse.
These are two very important operations  So take time to understand what is going on.
See JP pages 81 to 84 for some help.*

***Finally take a look at the subroutine Char_to_PC()
UCSR0A one of the HW registers that control the UART.
Open the data sheet. In the contents open section scroll down to section 24.12.2
UDRE0 is the name of one of the bits in this register. If it is 0 the UART is busy so we wait
If its 1 we can copy our character to UDR0 the UART data register and it will be transmitted. 
Scroll up a bit for more info on the register UDR0.*


***Page 3
3A looks at timer and keypress interrupts. 
Se JP p109 for a general intro.
When driving the display the micro spends most of its time doing nothing waiting for the end of our 100mS delay before updating the display. 
In this example the main task is printing out the results of some calculations. 
A HW timer is used to generate a 100mS tick.
Every 100mS it interrupts the printing process jumps to the ISR (interrupt service routine) update the display.
In addition a key press interrupt is shown to manipulate the display.*

***Look at the timer clock_tick() subroutine.
The timer is configured as a counter.
It counts from 0 to 12500 
TCCR1B sets a timer clock to 125KHz
So it takes 100ms to complete counting raise an interrupt and start again.*

***Both timer and UART have control registers that set their modes of operation. These registers have addresses and are all connected to a control bus.  A statements like TCCR1B = 0x03 uses the control bus to set register TCCR1B to 3. A bus refers to a set of connectors that transfer data from one part of the micro to another, in this case from the program running in memory to the timer.

Open up the data sheet section 15.11 to see the registers. We leave most of them alone but
set TCCR1B, TIMSK1 OCR1 and TCNT1.*

***3B looks at interrupts generated by pressing one of the user switches.
PCI stands for pin change interrupt.
Look at the header file for definitions of the macros.
See the data sheet sections 12.2.4 and 1 for detains of the PCI registers.

Note: Many things may look confusing.   If that each example successfully introduce one new thing that will be fine.*

***3C	Nothing new here, just included for a bit if extra practice

3D	Includes PCI and timer as well as the one wire comms interrupt.  Multiple interrupts can easily cause trouble.  To avoid this the PCI also resets the micro.  Before doing so it writes to the EEPROM.  After the reset it reads the EEPROM so that it knows which switch was pressed.  EEPROM is a special area of memory that survives power down and reset, which both usually result in all registers being reset to zero.
*



