
Text here is ignored

**********Proj_1A_LEDdisplay	THE FIRST PROGRAM:  Learning to drive the led segments.		This uses the display to generate a simple pattern that repeats endlessly.



LEARNING SOMETHING ABOUT THE C PROGRAMMING LANGUAGE

1.	The 'main' routine:
When power is applied or immediately after programming, program execution starts with the "main" routine. Note the '{}' symbols used to initiate and terminate this routine.




2.	The "for-loop":  Code within the {} brackets is executed 16 times as "m" increments from 1 to 16.  In C, 'm++;' is shorthand notation for add 1 to m.  When 'm' gets to 17 program execution jumps to the statement 'SW_reset;'.




3.	Variables: 'PORT_1' and 'm' are names assigned to variables.  They can take on numeric values which are the results of logical or arithmetic operations.  In this case 'PORT_1' is initialised to 1 and then doubled every time that the 'for-loop' repeats  (the shift symbol '<<' followed by 1 is equivalent to multiply by 2).




4.	Comments:  No text in green needs retyping to get the program working. This is what is called 'comment'.*





**********DISCOVERING THE ATMEGA HARDWARE (HW)




1.	The Central Processor Unit (CPU):  This is the unit that performs the arithmetic and logical operations (plus, minus, and, or, not etc.) including '<<' already referred to.

2.	Data memory also know as SRAM:  This is memory space in which variables such as 'PORT_1' and 'm' are stored.   In this case the variables are defined as integer, and 16 binary digits (bits) are reserved for each one.  16 bit numbers can hold 2^16 values.  PORT_1 which is unsigned can hold values from 0 to 65535. 'm' which is signed (by default) can hold numbers between -32,678 and +32677.

3.	Output ports: Output ports are connected to the display and used to power the segments. For each bit of PORT_1 there are corresponding segments in the display. For each bit that is set to 1 these segments are illuminated and each each bit that is set to 0 they are not.

4.	I2C bus: This enables data to be shared between the Atmega devices.  Here it is used to enable user code running on the UNO device to drive the display which is under the control of the PCB 111000_1 device.  

5.	A HW timer T0 that pauses program execution for 60ms in this case.*



**********INTRODUCING THE PROJECT FIRM WARE (FW)

1. 	The 'setup_HW' macro: This is a code segment that sets up the UNO device HW (hard ware). For example it determines which pins are to be configured as outputs and which as inputs.

2.	The I2C subroutine 'I2C_Tx_2_integers': This sends 32 data bits (each 0 or 1) over the I2C bus to the PCB 111000_1 device, where the mini-OS uses them to control illumination of the 32 vertical led segments.

3.	The 'SW_reset' statement: This causes program execution to repeat from the beginning as it does for a Power on Reset (POR) when power is first applied.

4.	The .h file: This gives details of 'setup_HW',  and 'SW_reset', and the location of the 'I2C subroutine'.  It also tells the compiler about certain WinAVR files that will be required.*



**********DRIVING THE DEVELOPMENT TOOLS

To create the .hex file click on 'tools' and then select 'Make All'. Select 'Make Clean' to delete all extra files generated except the .hex one. Note: The Makefile has been slightly edited to ensure that the .hex file is not also deleted.*



**********THE ALTERNATIVE VERSION OF THE PROGRAM		MORE ABOUT THE C PROGRAMMING LANGUAGE

1.	The 'while(1)' loop:	Code following the 'while(1)' statement and contained within the '{}' brackets is repeated endlessly.

Note: The result of replacing the '1' between the '()' brackets with a variable is that program execution only remains within the '{}' brackets while the variable is other than zero. It is normal for the variable to be adjusted every time that the loop is executed until of course it reaches zero when program execution exits the 'while-loop'.

2.	The presence of a 'for-loop' within the 'while-loop'.  The design of C allows programs to be readable despite a considerable degree of complexity. 

3.	The use of the tabs key to indent the code and make it easier to follow.

4. 	The idea that the '{}' brackets always occur in pairs, click on one bracket and its companion will also be highlighted.  Note the symmetry of the brackets.

5.	The delay introduced by the 'SW_reset' statement. As a result of the 'while(1)' statement there is no need to perform a SW_reset or put up with the delay that it introduces. However 'PORT_1' must be reset to 1 at the beginning of each 'while-loop'.


MORE ON DRIVING THE DEVELOPMENT TOOLS

Use the 'Tools/Options/Styles/Brace Match/Text Colour' dialogue to set the colours.  Make sure that the colour is very clear, in which case use of the tabs key is no longer really necessary and there is no need for code to take up so much space.*






**********Proj_1C1 Pin_Change_Interrupt	PROGRAM 3	A REACTION TIME TESTER		Test your reactions by attempting to shoot the LEDS down using switch_2 (the RH one).

SOME OF THE THINGS THIS PROGRAM INTRODUCES:


1.	Interrupts	(Signals generated by the Atmega HW):
An interrupt is a signal that interrupts normal program flow, which then temporarily leaves the main routine and jumps to a special subroutine known as an ISR (Interrupt Service Routine). On this PCB Interrupts can be generated by timers, by pressing a key on the PC or by operating one of the project pcb switches.  At the end of the ISR program flow returns to where it was when the interrupt occurred. 

2	config_sw1_and_sw2_for_PCI;	This is a project macro that sets up switch_2 to generate Pin Change interrupts (PCI). (sw1 is not used).

3.	ISR(PCINT2_vect){}:	This is the Interrupt Service Routine (ISR) that is called every time sw_2 is pressed or released. Note that program flow returns immediately when the switch is released so that it is only switch presses that have any effect.

4.	Global variables: 	Note that variables PORT_1 and mask are available to both the main routine and also to the ISR   (Note they are also volatile because of their use by the ISR).

5.	More complex logic:	Not really of interest at this stage. This has been added in an attempt to produce something interesting and its study may usefully be delayed.

6.	The statement if(m == 1) which means execute the next statement if m equals 1, but if it equals anything else skip the next statement.*


**********Proj_1F_PCI_and_T1_interrupt



MULTI PATTERN DISPLAY


Uses switch presses to select any one of six displays. A more ambitious program in which the inevitable complexity is handled by two subroutines (see below) and two interrupt service routines one triggered by a timer and the other by a switch press. One of the subroutines is used to initiate the display and the other to increment it.


IT INTRODUCES


1.	The Watch Dog Timer:	Part of the Atmega HW that can be programmed to generate a reset if program execution unexpectedly halts for any reason. 

2.	Interrupts from multiple sources:	Combining a timer interrupt to increment the display with a PCI interrupt to select the display and initialise it.

3.	Lots of logic; not really of interest here. 

4.	Subroutines:	A subroutine executes a segment of code on behalf of the main routine. Subroutines may be used to make a program more readable especially if the code segment is required several times. Alternatively the subroutine may provide a service like some arithmetic, that may be used by just one or by many programs.

Consider the project subroutine void Inc_Display(char mode).		It is called by the statement Inc_Display(switch_press);  

void Inc_Display(char mode) defines a variable and gives it the name mode.  The initial value of mode is supplied by the statement Inc_Display(switch_press) in the main routine in which switch_press is defined as a char variable. 

The subroutine can change the value of mode but these changes will not effect the variable switch_press in the main routine.  The term void indicates that the subroutine will not be returning any value to the main routine as might be the case for an arithmetic function for example.*



**********Proj_2A_reaction_time_tester		THE LAST of PROJ_1A: A REACTION TIME TESTER


Press SW2 and the leds scan across the display. Release it fast enough when they line up and the display will flash.

Lower leds sweep as for Proj_1A, when the display increments the next segment is illuminated. At the same time the upper leds increment by 1,2 or 3 leds in random order. Therefore it is only occasionally that a pair of segments are illuminated. This is when SW2 should be released.


DISCOVERING MORE ABOUT THE ATMEGA HW


1.	Power on Reset (POR).  	This is the condition of the microcontroller immediately after power has been applied.  Data memory is clear and operation starts with the "main" routine. This program like most of them will start when power is applied.  There is no need to connect the PCB to a PC. 

Other resets used in these projects are a reset pin (the external reset) that re-initiates operation immediately after programming, the watch dog timer that initiates a reset if it is allowed to time out 
and the brown out reset (BOR) that generates are reset if the supply voltage droops excessively.

2.	EEPROM memory.	This is memory that can be used to hold data that must not be lost when power is removed or an external reset or watch dog timeout occurs.


INTRODUCING RANDOM NUMBER GENERATION

1.	Project subroutine PRN_16bit_GEN()	The random number generator project subroutine "PRN_16bit_GEN()" can generate 2^16 -1 (65535) different numbers. Note there is a similar routine "PRN_8bit_GEN()" that can generate 255 different numbers. These generators use the top two locations of the EEPROM. 

Google "LFSR" (Linear-Feedback Shift Register) for details of random number generation.


OPERATION	Only use switch_2 the middle switch: Press it to start the display and when the segments line up release it immediately and they will flash.*




**********Proj_2G_Numerical_entry


A WAY OF DISPLAYING NUMBERS
The ability to illuminate any segment rather than just the vertical ones means that numbers can be displayed. 

IT INTRODUCES:

1.	Subroutine display_num_string ();
This uses subroutine I2C_Tx_any_segment() to display the digits 0 to 9

2.	The #define statement. 
This is used here to define each digit in terms of its segment letters. Each set of segment letters is known as a string and is stored in program memory in an array terminated in the null character '\0' or (0). When the compiler sees a digit name (i.e zero) it substitutes the address at which the first segment is stored.

3.	The askii code
This is used to represent symbols in numerical form. 
By incrementing the number from 32 to 126 most of the typewriter symbols from space to ~ are covered. For example the letters a to g are represented by the numbers 97 to 103.

4.	The macro User_prompt:	This repetitively sends a char (R) to the PC and pauses program execution until the user echoes it by pressing either R or r.

5.	More on pointers:

Consider the statement 	const char* string_ptr = 0;
The memory location "string_ptr" is preceded by a "*".
This tells the compiler that it will be used to hold the address of data to be operated on rather than the data itself (in this case the address of the first segment used to define a digit).

Consider the statement 	display_num_string(string_ptr, digit_num);
It call subroutine display_num_string() passing the data contained in  string_ptr and digit_num
However string_ptr contains an address and digit_num contains a number between 0 and 7

Consider the subroutine 	display_num_string (const char* s, int digit_num)
It provides a memory location for variable  digit_num.
It does not provide memory for the variable s.  Instead it uses the address stored in string_ptr.

6.  The "continue" statement.
Note that in a loop such as "for" or "while" a "break" statement causes program execution to jump to the statement following the end of the loop.
The "continue" statement causes program execution to jump to the bottom of the loop from where it repeats the loop again. Note that "break" is also used in the "case" construct.

Note:  
If the number 45 is entered the number 54 gets displayed.  This is a common problem with displaying and printing numbers.*



**********Proj_3E_Data_from_KBD to 


IT INTRODUCES


1.	Project subroutine "Num_from_KBD_Local()".

This subroutine acquires numerical keypresses and echoes them to the display. Note that the display is shifted one place to the left every time that a new digit is entered.

This subroutine ends by calling calls "I2C_displayToNum" which reads the display, converts the result to a number and sends it to the UNO.

2.	Project subroutine "Num_to_PC()".	This converts a number to askii characters using a radix of either 10 or 16. The resulting string is then sent to the PC using subroutine  "NumericString_to_PC()". 

3.	Project subroutine I2C_Tx_long(Num_1);	This uses the mini-OS to display a long number

4.	Project subroutine "wait_for_return_key()".  	This traps symbols '\r' (return) and '\n' (new line) and ensures that if both are present they are combined into a single '\r'. 

5.	A simple method of trapping overflow that occurs with multiplication.*

	


**********Proj_3G_Char_nos

USES THE DISPLAY TO EXPLORE THE OPERATION OF BINARY NUMBERS



IT INTRODUCES



1.  Binary notation for unsigned integers from 0 to 255 and signed integers between -128 and +127.

2.  Project subroutine "I2C_Tx_display_char(digit, mode)" where digit is any binary number between 0 and 11111111 
and mode is either "u" for unsigned or "s" for signed.


OPERATION

The 4 LHS digits of the display are used to display the binary number and the 4 RHS digits for the decimal number.
Press sw2 to increment the binary number or sw1 to decrement it.
sw3 toggles the display between "signed" and "unsigned" numbers.

Switch location on PCB:  SW1 - SW2 - SW3*



