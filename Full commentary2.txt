Full Project commentary
Page 1:

The idea for PCB111000 is based on the ATMEL AVR Butterfly module which came with an excellent text by Joe Pardue (JP) specifically written for the younger beginner.  Why not start by downloading the text and skimming through chapters 1 and 2.  Rather than the WinAVR compiler we now use Arduino.  Programmers notepad (pn) and Bray++ are both still invaluable. 

Our first project a simple C program is based on JP’s Blinky, see JP p30.   A selection is offered here.  Why not choose one and type it in. Click on Sketch then Verify/Compile. Fix the errors it reports (usually typos) then click on Export compiled Binary.  Connect the pcb to the computer, open Bray++; set the Baud rate to 57600, click on rescan, then connect.  At the user prompt press p, upload the hex file, then press r when the user prompt is reinstated.
Hopefully the display will burst into life.

Look at JP chapter 3 for an intro to Blinky.    Now look again at your own code and notice several lines:

#include “First_project_header.h”  	This contains additional information required by the compiler, including other .h and .c files with essential definitions and resource subroutines  (pn is recommended for opening these).   

setup_328_HW (Hard Ware and which is known as (k\a) a macro). Details are given in the header file.

Unsigned int PORT_1	PORT_1 is the name of a memory location that holds numbers.  The smallest element of computer memory is a bit and can hold either a 1 or a 0.  Memory is often divided into blocks of 8 bits. 16 bits are reserved for PORT_1. It can hold numbers between 0 and 2^16, but excluding 2^16 (2 raised to the power of 16) itself.  See JP chapter 4 for an introduction.

One_wire_Tx_2_integers(PORT_1, PORT_1)	This is a resource subroutine which sends data over the one wire link to the ATtiny device which uses it to drive the display.
Note: Subroutines are called by the main routine. Here we define them as either resource subroutines which are for general use or project subroutines which are written for a particular project.

sei(); 	This enables interrupts which are required by the one wire link (and will be discussed later)

SW_reset;	This is also a macro. It uses a device k/a a watch dog timer (wtd) to reset the program so that it repeats endlessly.

Having got the example working click on Tools/Auto Format. It makes the code much clearer to read.  Why not comment each line stating what it does as a learning aide (See JP p39).

Try several examples, they provide good practice at entering programs.  The for loop, the while loop and the if statement are very important features of C.  A good look at JP chapter 5: C Control flow is recommended before moving on from this first project.
Of less importance right now are the arithmetic and logic symbols included in the examples. JP gives full definitions of these in chapter 4. 

Example 8 introduces the resource subroutines
	PRN_16bit_GEN(0) which generates random numbers
	Timer_T2_10mS_delay_x_m() which uses a HW timer to generate delays

Example 9 introduces a project subroutine “backup_the_display()”
	This provides a service for the main routine
	Its main purpose here is to make the code easier to read 

Having looked at the examples why not mix and match to compose your own code.




Page 2
Introducing the USART (Universal …. Receiver Transmitter module)
Many devices have a receiver transmitter module for communicating with a PC.
See JP page 98 for a few details.
Arduino provides a comprehensive set of functions for using the USART.  Here basic do it yourself (DIY) functions are used.  This approach provides a good introduction to the data sheet, a vital resource for setting up other things such a timers and interrupts. 

Take a look at the project subroutine Char_to_PC_Local().
And see section 20.11.1 of the data sheet
UDR0 and UCSR0A are registers in the USART.  
Data to be transmitted must first be written to UDR0.
If data has been received it can be read from UDR0.

UDRE0 is bit 5 of register UCRS0A.  
The USART sets this bit to one when it is ready to accept new data for transmission.
Similarly it sets bit RXC0 to 1 when data has been received and can be read. 

A number of these DIY functions can be found in 
Resources_Receiver_transmitter\Basic_IO_and_Timer
They are best viewed using programmers notepad (pn).

Example 1 simply echoes keypresses to the screen

Example 2 prints many of the common characters to the screen 
Clicking on the hex button in the receive section of the Bray window shows that each character is represented by a number. See JP p283.

Example 3 prints a file. 
Resource “isCharavailable(65)” returns a 1 immediately if a character is received in a 1 second window.  Otherwise it returns zero and is called again.
Having received the first character it can then receive any number but will exit (break) immediately if no character is received after a pause of 154mS.

Example 4 introduces character strings and shows they can be sent to the PC. 
It also shows how they are stored in arrays (consecutive locations) in memory.
We compose the strings and choose a name for each one.
The compiler adds a 0 to the end of each string.  It also replaces the names (i.e.  message_1) with the address of the first character in the string. 

Note the two ways of writing the appropriate the C statements:
The * character indicates that memory location message_1 holds an address.
The [] characters indicate that message_3 is an array of characters.


Example 5 simply prints out the characters together with their numeric equivalents

Example 6 Converts a number to a string of characters and sends them to the PC and
Example 7 Does the reverse.
These are two very important operations. Take time to understand what is going on.
See JP pages 81 to 84 for some help.


Example 8  A bit more on pointers

All variables in the main routine (i.e. PORT_1) are given permanent locations in memory.
Subroutines all share a common area of memory and so the variables in a subroutine must all be initialised before it runs.
Sometimes it is necessary for a subroutine to modify the value of a variable each time that it runs or to share it with another subroutine. In this case it must also have a permanent memory location.

These can be achieved by declaring the variables in the header file rather than in the main routine. They are then known as global variables and can be modified by any subroutine or ISR. 
Alternatively the subroutine can access a memory location reserved for the main routine.

In this example subroutine test reserves temporary storage for variable any letter.
For the variable offset however it expects the main routing to provide a permanent memory location.  The character * and & are used as shown to ensure that this happens.  See JP chapter 8.



Page 3
3A looks at timer and keypress interrupts. 
Se JP p109 for a general intro.
In our first projects the micro spent most of its time waiting for a delay to complete before updating the display. 
In this example its main task is to do some calculations and print out the results. 
A HW timer runs in the background. Every 100mS it generates an interrupt.   The micro temporarily  leaves the printing process, jumps to the ISR (interrupt service routine) and the display is updated.
A key press interrupt is also shown enabling users to to manipulate the display manually.

Look at the timer clock_tick() subroutine.
The timer is configured as a counter.
It counts from 0 to 12500 
TCCR1B sets a timer clock to 125KHz
So it takes 100ms to complete counting raise an interrupt and start again.

Open up the data sheet section 15.11 to see the registers. We leave most of them alone but
set TCCR1B, TIMSK1 OCR1 and TCNT1.

3B looks at interrupts generated by pressing one of the user switches.
PCI stands for pin change interrupt.
Look at the header file for definitions of the macros.
See the data sheet sections 12.2.4 and 1 for details of the PCI registers.

3C	Nothing new here, just included for a bit if extra practice

3D	Includes PCI and timer as well as the one wire comms interrupt.  Multiple interrupts can easily cause trouble.  To avoid this the PCI also resets the micro.  Before doing so it writes to the EEPROM.  After the reset it reads the EEPROM so that it knows which switch was pressed.  EEPROM is a special area of memory that survives power down and reset, which both usually result in all registers being reset to zero.